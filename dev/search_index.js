var documenterSearchIndex = {"docs":
[{"location":"Quickstart/#Quickstart-tutorial","page":"Quickstart tutorial","title":"Quickstart tutorial","text":"","category":"section"},{"location":"Quickstart/","page":"Quickstart tutorial","title":"Quickstart tutorial","text":"A lens can easily be defined, plotted, and evaluated in ten lines of code as shown in this tutorial.  The first few lines are for definition of system geometry, then bundle definition defines the rays for analysis, and finally the evaluation of the optical stack on the bundle yields the trace and plots used for analysis.","category":"page"},{"location":"Quickstart/#System-geometry","page":"Quickstart tutorial","title":"System geometry","text":"","category":"section"},{"location":"Quickstart/","page":"Quickstart tutorial","title":"Quickstart tutorial","text":"The system geometry is defined by ","category":"page"},{"location":"Quickstart/","page":"Quickstart tutorial","title":"Quickstart tutorial","text":"using GeometricalOptics\n\nfuncsList = [spherical, spherical, zplane]\ncoeffsList = [[1., 6.], [2., -6.], [8.]]\nnList = [1., 1.5, 1.]\n\noptSta = opticalstack(coeffsList, funcsList, nList)","category":"page"},{"location":"Quickstart/","page":"Quickstart tutorial","title":"Quickstart tutorial","text":"To understand how this works, note that each surface in funcsList has an associated Vector in coeffsList and value in nList. The positions in all three Vectors line up. The coefficient list entry is used for the corresponding surface, and the index of refraction entry is for the space preceding the corresponding surface. The \"precedence\" in the previous sentence is set by the sequence of the surfaces in surfList and therefore the order of traversal of the surfaces by the ray bundle. By contrast, surface precedence is not explicitly implied by the definition of the surface geometry.  This is useful for defining different types of systems.","category":"page"},{"location":"Quickstart/","page":"Quickstart tutorial","title":"Quickstart tutorial","text":"The spherical surface has its own coefficient Vector definition. It is spherical(x,y,coeffs) where coeffs=[zpos,signed_radius] with entries z-position and signed radius, accordingly.  This functionality extends to allow simple user defined functions: the user can define a new function my_ytilt(x,y,coeffs)=coeffs[1]+coeffs[2]*y, which creates a tilted plane with z position set by the first entry in coeffs and y tilt set by the second entry.  The user would then pass in my_ytilt with no arguments to the function list vector (funcsList above).  This is explored with a more complicated and fun surface in Sideloading a new surface function: caustics in the swimming pool.","category":"page"},{"location":"Quickstart/","page":"Quickstart tutorial","title":"Quickstart tutorial","text":"Here there are three surfaces.  System units are arbitrary and can be prescribed based on the needs of demonstration.  The light will propagate through air (index of refraction n=1.0) to a spherical surface with apex at z=1 and radius +6.0, and then refract into a medium of n=1.5.  Then the light will propagate through a glass (n=1.5) to a second surface with apex at z=2 and radius -6.0.  Finally the light will refract back out to air and propagate to a z-plane (zplane) at z=8.0.","category":"page"},{"location":"Quickstart/#Ray-geometry","page":"Quickstart tutorial","title":"Ray geometry","text":"","category":"section"},{"location":"Quickstart/","page":"Quickstart tutorial","title":"Quickstart tutorial","text":"The least verbose method to trace a bundle of light is by using the square bundle definition bundle(x,y,angx,angy,zpos). Other bundles are possible; for example, bundle_as_array can make a circular bundle as shown in Vectorizing over index, 3D analysis. In this construction, x,y,zpos are physical positions, and angx,angy are tilts in radians away from the z-axis in the x and y directions respectively (arguments of direction tangents).  By convention, the rays all originate from the same z position given by scalar zpos. Arguments x,y can be Vectors and the rest scalars to make the bundle of rays all parallel or collimated.  These Vectors need not be the same length; this sets the count of the rays in either direction. If x::Vector{T} where T<:Real = [0.] as below, the rays will all begin with coordinate x=0, and have y values given by the extent of the vector in y.","category":"page"},{"location":"Quickstart/","page":"Quickstart tutorial","title":"Quickstart tutorial","text":"test_bundle = bundle([0.], (-1:0.2:1), 0., 0., 0.)","category":"page"},{"location":"Quickstart/","page":"Quickstart tutorial","title":"Quickstart tutorial","text":"Analogously, another bundle can be traced but have angx,angy as Vectors and all other arguments as scalars. This would correspond with all rays originating from a point in space with a particular array of angles.  In any event, the bundle represents an array of input rays.","category":"page"},{"location":"Quickstart/#Evaluation-and-plotting","page":"Quickstart tutorial","title":"Evaluation and plotting","text":"","category":"section"},{"location":"Quickstart/","page":"Quickstart tutorial","title":"Quickstart tutorial","text":"The output of the method on the instance of opticalstack is variable depending on keyword. ","category":"page"},{"location":"Quickstart/","page":"Quickstart tutorial","title":"Quickstart tutorial","text":"With a bundle passed in and no render optional argument rend used the default output is a trace.","category":"page"},{"location":"Quickstart/","page":"Quickstart tutorial","title":"Quickstart tutorial","text":"Passed into rac, the ray lateral coordinate at one position in trajectory can be plotted as a function of ray lateral coordinate at another position.  In this case, the position is related to the ray bundle information.  Index 1 corresponds to the set of ray information before striking any surfaces, and the last index corresponds to the ray information at the last requested surface.  Therefore when traveling through k surfaces, the number of positions along ray trajectory will be (k+1).  The three-surface system is evaluated at ray position four with respect to ray position one.","category":"page"},{"location":"Quickstart/","page":"Quickstart tutorial","title":"Quickstart tutorial","text":"trace1 = optSta(test_bundle)\np_rac = rac(trace1, 1, 4)","category":"page"},{"location":"Quickstart/","page":"Quickstart tutorial","title":"Quickstart tutorial","text":"The bundle strikes the final surface on a z-plane.  Root-mean-square ray deviation rms_spot with no optional keyword pos is evaluated at the last surface.","category":"page"},{"location":"Quickstart/","page":"Quickstart tutorial","title":"Quickstart tutorial","text":"rms = rms_spot(trace1)","category":"page"},{"location":"Quickstart/","page":"Quickstart tutorial","title":"Quickstart tutorial","text":"The trace can be evaluated by other means using the evaluation functions explained in Bundle, surface, and trace options. The bigtrace type stores more information than the trace type and can be extracted by setting optional argument isbigtrace=true into the opticalstack call. ","category":"page"},{"location":"Quickstart/","page":"Quickstart tutorial","title":"Quickstart tutorial","text":"If the render mode keyword rend is used, the output is a plot, here set as a 2D plot of the lens in the YZ plane:","category":"page"},{"location":"Quickstart/","page":"Quickstart tutorial","title":"Quickstart tutorial","text":"p_lens = optSta(test_bundle; rend = \"YZ\")\n","category":"page"},{"location":"Quickstart/","page":"Quickstart tutorial","title":"Quickstart tutorial","text":"Argument options for plotting are rend=\"YZ\", rend=\"XZ\", rend=\"3Dcirc\", rend=\"3Dsq\".  The global plot domain of surfaces can be adjusted by xdom and ydom.","category":"page"},{"location":"Quickstart/","page":"Quickstart tutorial","title":"Quickstart tutorial","text":"The various plots can be plotted statically as shown in the docs or as interactive plots by using the plotly backend of Plots with this package. Just add using Plots; Plots.plotly() and the plots will be interactive.","category":"page"},{"location":"Quickstart/","page":"Quickstart tutorial","title":"Quickstart tutorial","text":"p_lens = optSta(test_bundle; rend = \"YZ\", ydom = -2:0.1:2)\n","category":"page"},{"location":"Quickstart/","page":"Quickstart tutorial","title":"Quickstart tutorial","text":"Yes, this is the eleventh line of code for those of you keeping count, and I said ten lines. But it's not necessary to repeat the plotting operation. You get the point :)","category":"page"},{"location":"Quickstart/#*Now,-what-next?*","page":"Quickstart tutorial","title":"Now, what next?","text":"","category":"section"},{"location":"Quickstart/","page":"Quickstart tutorial","title":"Quickstart tutorial","text":"There are other methods and types in GeometricalOptics.jl which can be used, and this package can be interfaced with other packages in Julia.  Other more complicated demonstrations can be constructed as in Examples (2D and 3D). But the core functionality still remains the same as in this tutorial.  The opticalstack connects a bundle of rays and with a sequence of surfaces. Simply substitute different functions for surfaces or vectorize over lenses to look at different configurations depending on the behavior you wish to demonstrate.  Other bundle prescriptions are also possible.  The abstract vectorization of Julia allows a surprisingly intuitive extension of this simpler example to other practical demonstrations.","category":"page"},{"location":"Reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"Reference/","page":"Reference","title":"Reference","text":"Modules=[GeometricalOptics]","category":"page"},{"location":"Reference/#GeometricalOptics.bigtrace","page":"Reference","title":"GeometricalOptics.bigtrace","text":"bigtrace(xr, yr, zr, Dxr, Dyr, Dzr, nsr)\n\nComposite type holding position, direction, and accumulated optical path for parsing. Each is Type Matrix{Vector{T}} where T<:Real,  vector holding information along propagation and the matrix mapping to the chosen input bundle subscripting.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GeometricalOptics.bundle","page":"Reference","title":"GeometricalOptics.bundle","text":"bundle(x, y, angx, angy, zpos)\n\nComposite type representing the origination of a bundle of rays. Input zpos is type T<:Real  and is z-plane start position for the rays. Other four arguments are typed in one of the following two patterns:\n\nx and y are Type AbstractArray{T,1} where T<:Real, angx and angy are Type T where T<:Real\nx and y are Type T where T<:Real, angx and angy are Type AbstractArray{T,1} where T<:Real}\n\nWhen a variable is declared this type with specific parameters and called  as a function with no arguments, it returns a tuple (position, direction) each  entry of which is an output array of vectors corresponding to the input information.\n\nExamples\n\njulia> eval_bundle = bundle([0., 1.], [0.,1.], 0., 0., 0.)\nbundle([0.0, 1.0], [0.0, 1.0], 0.0, 0.0, 0.0)\n\njulia> eval_bundle()\n([[0.0, 0.0, 0.0] [0.0, 1.0, 0.0]; [1.0, 0.0, 0.0] [1.0, 1.0, 0.0]], [[0.0, 0.0, 1.0] [0.0, 0.0, 1.0]; [0.0, 0.0, 1.0] [0.0, 0.0, 1.0]])\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GeometricalOptics.bundle_as_array","page":"Reference","title":"GeometricalOptics.bundle_as_array","text":"bundle_as_array(x, y, angx, angy, zpos)\n\nComposite type representing the origination of a set of rays. First four arguments are  Type AbstractMatrix{T} where T<:Real; last argument is a scalar for the z position.\n\nWhen a variable is declared this type with specific parameters and called  as a function with no arguments, it returns a tuple (position, direction) each  entry of which is an output array of vectors corresponding to the input information.\n\nExamples\n\njulia> eval_bundle = bundle_as_array([0.5 1.], [0.5 1.], [0. 0.], [0. 0.], 0.)\nbundle_as_array{Float64}([0.5 1.0], [0.5 1.0], [0.0 0.0], [0.0 0.0], 0.0)\n\njulia> eval_bundle()\n([[0.5000000000000002, 0.5000000000000002, 2.220446049250313e-16] [1.0000000000000002, 1.0000000000000002, 2.220446049250313e-16]], [[0.0, 0.0, 1.0] [0.0, 0.0, 1.0]])\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GeometricalOptics.bundle_as_array_big","page":"Reference","title":"GeometricalOptics.bundle_as_array_big","text":"bundle_as_array_big(x, y, z, Dx, Dy, Dz)\n\nComposite type representing the origination of a set of rays. All arguments are Type AbstractArray{T,2} where T<:Real.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GeometricalOptics.opticalstack","page":"Reference","title":"GeometricalOptics.opticalstack","text":"opticalstack_instance = opticalstack( ... )\n\n... = opticalstack_instance( ... )\n\nFor surface reflection and refraction use this method to define an instance of the opticalstack type\n\nopticalstack(coeffslist, surfslist, nlist)\n\nFor gradient index (and surface reflection and refraction) use this method to define an instance of the opticalstack type\n\nopticalstack(coeffslist, surfslist, nlist, ncoeffslist, grindt)\n\nFor grating/hologram/metasurface (and surface reflection and refraction) use this method to define an instance of the opticalstack type\n\nopticalstack(coeffslist, surfslist, nlist, diffractiveslist, diffcoeffslist, diffmlist, wavelength)\n\nTo use all features together use this method to define an instance of the opticalstack type\n\nopticalstack(coeffslist, surfslist, nlist, diffractiveslist, diffcoeffslist, diffmlist, wavelength, ncoeffslist, grindt)\n\nArguments to create an instance of opticalstack are \n\ncoeffslist is a Vector set of coefficients for a corresponding surface; each set of coefficients is itself also a Vector.\nsurfslist is a Vector of functions callable on (x, y, coeffs) to return a z-zurface position.\nnlist is a Vector of index values or index functions corresponding to the medium before the corresponding surface.\nVector values T<:Real work universally\nVector input of mixed type, Real and functions n where n(x, y, z, coeffs) = ..., only works for declarations of opticalstack which define ncoeffslist and grindt as well.\nncoeffslist::Vector{Vector{T}} where T<:Real is a Vector set of coefficients for a corresponding gradient index; each set of coefficients is itself also a Vector.\ngrindt::Real is the Sharma ray increment in the gradient index medium. \nThis step parameter scales the physical quantity OPn² (optical path length and index of refraction) at every step, and raytracing is by the algorithm of Sharma et al. 1982.\ndiffractiveslist is a Vector of zeros and functions. Where a vector entry is not zero, the entry must be a valid phase function, e.g. ϕ where ϕ(x y z coeffs) =  sampled by the surface at a corresponding position to make the diffractive.\ndiffcoeffslist::Vector{Vector{T}} where T<:Real is a Vector set of coefficients for a corresponding diffractive; each set of coefficients is itself also a Vector.\ndiffmlist::Vector{Int} must have the integer corresponding to the diffraction order in the vector position corresponding to the position of the diffractive surface.\nwavelength::Real is the wavelength in system units simulated for the definition of the diffractive.\n\nWhen an instance is declared, opticalstack_instance = opticalstack( ... ), the declared instance is called on a bundle instance bundlething and optional arguments as\n\nopticalstack_instance(bundlething; rend = nothing, color = :red, issurfplot = true, numsurfpoints = 20, halfdomain = nothing, xdom = nothing, ydom = nothing, plobj = nothing, isbigtrace = false, plotplane_at = 0., init_prop_guesses=nothing)\n\nWhen rend is nothing and isbigtrace = false the output is a trace type.\nWhen rend is nothing and isbigtrace = true the output is a bigtrace type.\nWhen rend is not nothing, rend must be \"YZ\" or \"XZ\" or \"3Dcirc\" or \"3Dsq\". The output will be a plot object compatible with Plots.jl\nWhen rend is not nothing and issurfplot = false the surfaces being modeled will not be plotted.\nThe domain plot can be scaled globally by entering a vector of desired plot extent into xdom or ydom. This is preferred over using numsurfpoints and halfdomain.\nplotplane_at is the value at which a 2D plot is sliced in the non-plotted dimension.\ninit_prop_guesses::Vector{T} where T<:Real is an option to declare a first guess in numerical propagation preceding surface in the corresponding vector entry. \nDefaults to zero.\nNot recommended to use a nonzero value when traversing a gradient index function. \n\nNote that the data scaling of the output of gradient index analysis is not only with the number of rays but also with the resolution of propagation.  Assuming that propagation occurs over some position difference Δz, this data scaling is APPROXIMATELY Δz/dt. As expected, dt trades precision for computation time.\n\nNote for gradient index surfaces the output ray coordinates are stacked according to propagation needed for the \"longest\" gradient index ray. Therefore a returned trace or bigtrace will not be easily indexed according to its surface, but all propagation positions will properly align when entering and exiting the gradient index. Shorter rays will replicate their terminated values until the longest ray terminates. Then all rays will exit the gradient index together at the appropriate surface.\n\nNote for diffractive surfaces, the optical path contribution of the corresponding surface is that due to its preceding propagation PLUS that due to the diffraction phase function.\n\nNote that the index of refraction must be equal on both sides of the diffractive.  To work with cases where the diffractive sits on a substrate of different index of refraction, two surfaces should be collocated in sequence, one for reflection/refraction and one for diffraction.\n\nExamples\n\njulia> opticalstack_test = opticalstack([[1., 6.], [2., -6.], [4., 8.]], [spherical, spherical, zernike], [1., 1.5, 1.])\nopticalstack{Float64}([[1.0, 6.0], [2.0, -6.0], [4.0, 8.0]], UnionAll[spherical, spherical, zernike], [1.0, 1.5, 1.0])\n\njulia> bundle_test = bundle([0.5, 1.], [0.5, 1.], 0., 0., 0.)\nbundle([0.5, 1.0], [0.5, 1.0], 0.0, 0.0, 0.0)\n\njulia> tracething = opticalstack_test(bundle_test)\ntrace{Float64}([[0.5, 0.5, 0.4742890889441142, -0.024645519233983726] ... ; ...])\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GeometricalOptics.trace","page":"Reference","title":"GeometricalOptics.trace","text":"trace(xr, yr, zr, nsr)\n\nComposite type holding position and accumulated optical path for parsing. Each is Type Matrix{Vector{T}} where T<:Real,  vector holding information along propagation and the matrix mapping to the chosen input bundle subscripting.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GeometricalOptics.aspherical-Tuple{Real, Real, Vector{T} where T<:Real}","page":"Reference","title":"GeometricalOptics.aspherical","text":"aspherical(x, y, coeffs)\n\nComposite type representing aspherical surface as a function of lateral coordinate x,y. Argument coeffs of type Vector{T} where T<:Real has entries coeffs = [zpos, R,κ, A4, A6, ...] where the surface is \n\nz(xy) = zpos + r²  R  (1 + (1 - (1 + κ)r²  R²)) + A₄r⁴ + A₆r⁶ +  where r²  x² + y²\n\nExamples\n\njulia> aspherical(0., 2., [1., -10., -4., 0.001])\n1.0616649185805458\n\n\n\n\n\n","category":"method"},{"location":"Reference/#GeometricalOptics.bigtrace_to_bundle-Tuple{bigtrace, Int64}","page":"Reference","title":"GeometricalOptics.bigtrace_to_bundle","text":"bigtrace_to_bundle(tracething::bigtrace, pos_prop::Int)\n\nTakes a bigtrace object and integer position pos_prop and returns a bundle object.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#GeometricalOptics.rac-Tuple{Any, Any, Any}","page":"Reference","title":"GeometricalOptics.rac","text":"rac(tracething::Union{trace, bigtrace}, pos_in, pos_out; pl_rac = nothing, color = :red, axistype = \"y\", pmajoraxis = 2)\n\nPlots the chosen physical coordinate axistype=y or x at an end position pos_out of a particular trace or bigtrace object as a function of the same coordinate at input position pos_in. If pos===nothing, the last position in the trace is  used. The coordinate plots are stitched together in lines based on the chosen matrix subscript in the trace or bigtrace.  This matrix subscript is set by the optional argument pmajoraxis = 2 or 1. Can optionally pass in a handle to existing plot pl_rac, and change the plot color from default color=:red to any  of the conventional options supported by Plots.jl.\n\nNOTE that when tracing a ray fan (a bundle with one dimension of the array having length 1), the pmajoraxis must be set to the correct number to span the nonunitary length of the array. Else the plot may not appear to show anything.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#GeometricalOptics.rms_spot-Tuple{Any}","page":"Reference","title":"GeometricalOptics.rms_spot","text":"rms_spot(tracething::Union{trace, bigtrace}; isunsqrt = false, pos = nothing, iszincluded = true)\n\nEvaluates the rms spot size for a trace intersecting a surface. \n\nPass in the result of a trace, and calcuate the rms spot based on the ray values for the subscript pos. If  pos===nothing then the final values of the trace are used (i.e. the final surface is taken to be the evaluation surface). Option isunsqrt removes the square root from the calculation (returns the sum of squared error instead). The z coordinate variation is included in the calculation when iszincluded == true.\n\nExamples\n\njulia> opticalstack_test = opticalstack([[1., 6.], [2., -6.], [4., 8.]], [spherical, spherical, zernike], [1., 1.5, 1.])\nopticalstack{Float64}([[1.0, 6.0], [2.0, -6.0], [4.0, 8.0]], UnionAll[spherical, spherical, zernike], [1.0, 1.5, 1.0])\n\njulia> bundle_test = bundle([0.5, 1.], [0.5, 1.], 0., 0., 0.)\nbundle([0.5, 1.0], [0.5, 1.0], 0.0, 0.0, 0.0)\n\njulia> tracething = opticalstack_test(bundle_test)\ntrace{Float64}([[0.5, 0.5, 0.4742890889441142, -0.024645519233983726] [0.5, 0.5, 0.47749522247588994, -0.04245690108918665]; [1.0, 1.0, 0.9549904449517799, -0.0849138021783733] [1.0, 1.0, 0.9616736859140215, -0.1253539680837904]], [[0.5, 0.5, 0.4742890889441142, -0.024645519233983726] [1.0, 1.0, 0.9549904449517799, -0.0849138021783733]; [0.5, 0.5, 0.47749522247588994, -0.04245690108918665] [1.0, 1.0, 0.9616736859140215, -0.1253539680837904]], [[0.0, 1.0418113625438212, 1.9623895629300963, 7.999999280260749] [0.0, 1.105086411777687, 1.904234300100513, 7.999999273328101]; [0.0, 1.105086411777687, 1.904234300100513, 7.999999273328101] [0.0, 1.169047547709123, 1.8438309411610754, 7.999999266127459]], [[0.0, 1.0418113625438212, 2.9446610481344417, 9.023361779810676] [0.0, 1.105086411777687, 2.8587256850369682, 9.064376469832027]; [0.0, 1.105086411777687, 2.8587256850369682, 9.064376469832027] [0.0, 1.169047547709123, 2.7690064459109145, 9.114214613215701]])\n\njulia> rms_spot(tracething)\n0.1125476814135891\n\n\n\n\n\n","category":"method"},{"location":"Reference/#GeometricalOptics.spherical-Tuple{Real, Real, Vector{T} where T<:Real}","page":"Reference","title":"GeometricalOptics.spherical","text":"spherical(x, y, coeffs)\n\nComposite type representing spherical surface with apex at defined point. Argument coeffs of type Vector{T} where T<:Real has entries coeffs = [zpos, signed_radius]. Here zpos is the apex and signed_radius has magnitude equal to the radius of the sphere  and sign which sets the direction of curvature of the sphere.\n\nExamples\n\njulia> spherical(0., 2., [1., -10.])\n0.7979589711327115\n\n\n\n\n\n","category":"method"},{"location":"Reference/#GeometricalOptics.splot-Tuple{Any}","page":"Reference","title":"GeometricalOptics.splot","text":"splot(tracething::Union{trace, bigtrace}; pos=nothing, pl_splot = nothing, color = :red, markersize = 2)\n\nPlots the spot of a particular trace or bigtrace object at position pos. If pos === nothing, the last position in the trace is  used. Can optionally pass in a handle to existing plot pl_splot, and change the marker size from default markersize = 2 and the plot color from default color = :red to any  of the conventional options supported by Plots.jl.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#GeometricalOptics.trace_extract_ray-Tuple{bigtrace, Int64, Int64}","page":"Reference","title":"GeometricalOptics.trace_extract_ray","text":"trace_extract_ray(tracething::Union{trace, bigtrace}, i::Int, j::Int; coord = \"all\")\n\nTakes a trace or bigtrace object and integers i,j and returns the ray at position in the traced bundle array i,j.\n\nCoordinates are x, y, z, direction cosines are Dx, Dy, Dz and accumulated optical path is ns.\n\nOptional argument coord can be set \"all\" to return all information as Matrices.  This will be passed out as\n\nx, y, z, ns for trace object\nx, y, z, Dx, Dy, Dz, ns for bigtrace object\n\nOr optional argument can be set to a different string to only pass out one matrix of information.\n\n\"x\", \"y\", \"z\", \"ns\" for trace object\n\"x\", \"y\", \"z\", \"Dx\", \"Dy\", \"Dz\", \"ns\" for bigtrace object\n\n\n\n\n\n","category":"method"},{"location":"Reference/#GeometricalOptics.trace_extract_terminus-Tuple{bigtrace, Any}","page":"Reference","title":"GeometricalOptics.trace_extract_terminus","text":"trace_extract_terminus(tracething::Union{trace, bigtrace}, pos_prop::Int; coord=\"all\")\n\nTakes a trace or bigtrace object and integer position pos_prop and returns matrices of coordinates according to the bundle.\n\nCoordinates are x,y,z, direction cosines are Dx,Dy,Dz and accumulated optical path is ns.\n\nOptional argument coord can be set \"all\" to return all information as Type Matrix.  This will be passed out as\n\nx, y, z, ns for trace object\nx, y, z, Dx, Dy, Dz, ns for bigtrace object\n\nOr optional argument can be set to a different string to only pass out one Matrix of information.\n\n\"x\", \"y\", \"z\", \"ns\" for trace object\n\"x\", \"y\", \"z\", \"Dx\", \"Dy\", \"Dz\", \"ns\" for bigtrace object\n\n\n\n\n\n","category":"method"},{"location":"Reference/#GeometricalOptics.zernike-Tuple{Real, Real, Vector{T} where T<:Real}","page":"Reference","title":"GeometricalOptics.zernike","text":"zernike(x, y, coeffs)\n\nComposite type representing OSA/ANSI type Zernike polynomial surface as a function of lateral coordinate x, y. Argument coeffs of type Vector{T} where T<:Real has entries coeffs = [rad, C0, C1, C2, ...]. The normalization radius is rad and the corresponding Zernike surface is given by the contributions of the Zⱼ with arguments over the cartesian coordinates normalized to the unit disk, i.e.:\n\nz(x y) = ⱼCⱼZⱼ(r θ) where r  ( x² + y² )  rad and θ  atan(y  x)\n\nNOTE this function evaluates to NaN outside of the normalization radius.\n\nExamples\n\njulia> zernike(0., 2., [2., 0., 1.])\n2.0\n\n\n\n\n\n","category":"method"},{"location":"Reference/#GeometricalOptics.zplane-Tuple{Real, Real, Vector{T} where T<:Real}","page":"Reference","title":"GeometricalOptics.zplane","text":"zplane(x, y, coeffs)\n\nComposite type representing a plane z(x, y) = zpos. Argument coeffs of type Vector{T} where T<:Real has entries coeffs = [zpos]. \n\nExamples\n\njulia> zplane(0., 2., [3.])\n3.0\n\n\n\n\n\n","category":"method"},{"location":"TroubleConv/#Troubleshooting-and-Conventions","page":"Troubleshooting and Conventions","title":"Troubleshooting and Conventions","text":"","category":"section"},{"location":"TroubleConv/","page":"Troubleshooting and Conventions","title":"Troubleshooting and Conventions","text":"Geometrical optics usually relies on some choice of conventions.  This package is no exception. Some conventions describe choice of geometry and some describe potential pitfalls in analysis.  Some helpful tips are below.  Most of these tips are illustrated in the Quickstart tutorial and in Examples (2D and 3D).","category":"page"},{"location":"TroubleConv/","page":"Troubleshooting and Conventions","title":"Troubleshooting and Conventions","text":"Physical coordinates are arbitrary; units need only be kept self-consistent.\nRays may fail to properly trace with respect to surfaces when sufficiently steep.\nIndex of refraction is defined before its corresponding surface, where the light originates.\nRay bundles and surfaces are all defined in global coordinates to minimize ambiguity.\nReflection mode is defined by a sign change on the index of refraction after a given surface.\nCurrently, rays must be known to intersect the surfaces in the prescribed sequence a priori. \nThis is especially important to bear in mind for gradient index media where curved rays may significantly diverge.\nSurfaces, index functions, and phase functions defined by the user are not limited by form, but are limited by automatic-differentiability.\nThis will not likely be an issue with compositions of continuous math functions.\nFailures are likely to arise if the chosen function cannot be understood by ForwardDiff.jl.\n3D plotting does not always maintain proper aspect ratio, but 2D plotting does.  This is a consequence of dependency.\nWhere 1:1 aspect ratio is important, 2D plots should be used.","category":"page"},{"location":"Options/#Bundle,-surface,-and-trace-options","page":"Bundle, surface, and trace options","title":"Bundle, surface, and trace options","text":"","category":"section"},{"location":"Options/","page":"Bundle, surface, and trace options","title":"Bundle, surface, and trace options","text":"Each system for analysis takes some configuration of bundle and surfaces as input, and produces a trace.  The built-in options are summarized as follows (more details in Reference):","category":"page"},{"location":"Options/#Bundles","page":"Bundle, surface, and trace options","title":"Bundles","text":"","category":"section"},{"location":"Options/","page":"Bundle, surface, and trace options","title":"Bundle, surface, and trace options","text":"Physically, x,y,z are position and angx,angy are direction tangent angles (angles in radians). zpos is a fixed z position.  Dx,Dy,Dz are direction cosine (unit vector) components.","category":"page"},{"location":"Options/","page":"Bundle, surface, and trace options","title":"Bundle, surface, and trace options","text":"bundle(x,y,angx,angy,zpos) is a bundle which takes either vectors in x and y or vectors in angx and angy.  All other arguments are scalar.  Vectors may be different length to form rectanglular array sampling. \nbundle_as_array(x,y,angx,angy,zpos) takes matrices Matrix{T} where T<:Real for the first four arguments, and a scalar for zpos::T where T<:Real.\nbundle_as_array_big(x,y,z,Dx,Dy,Dz) takes all arguments as type Matrix{T} where T<:Real.","category":"page"},{"location":"Options/#Surfaces","page":"Bundle, surface, and trace options","title":"Surfaces","text":"","category":"section"},{"location":"Options/","page":"Bundle, surface, and trace options","title":"Bundle, surface, and trace options","text":"zplane is a z-plane, with one coefficient used to describe the fixed z-location of the plane.\nspherical is a sphere, with one coefficient used to describe the z-location of the apex, and the other to describe the signed radius of curvature relative to that apex.\naspherical is an aspherical surface, with coefficients describing the z-location, signed radius, conic constant, and arbitrary number of even order radial polynomial contributions.\nzernike is a zernike polynomial series representation. The normalization radius and arbitrary number of OSA/ANSI coefficients can be provided in coeffs. Rays will terminate with NaN if they strike outside the normalization radius for this built-in function.","category":"page"},{"location":"Options/#Traces-and-trace-methods","page":"Bundle, surface, and trace options","title":"Traces and trace methods","text":"","category":"section"},{"location":"Options/","page":"Bundle, surface, and trace options","title":"Bundle, surface, and trace options","text":"Traces are generated when a type of bundle is sent through an opticalstack type.  Methods on traces either return organized information on the rays traced from the bundle, or directly return some basic diagnostic.","category":"page"},{"location":"Options/","page":"Bundle, surface, and trace options","title":"Bundle, surface, and trace options","text":"trace is a Type which contains matrices of ray coordinates at all points in propagation.\nbigtrace is a Type which contains matrices of ray coordinates and direction cosines at all points in propagation.\nbigtrace_to_bundle returns a bundle object from the ray information at a particular position along propagation in a bigtrace. ","category":"page"},{"location":"Options/","page":"Bundle, surface, and trace options","title":"Bundle, surface, and trace options","text":"Built-in methods to extract data from a trace:","category":"page"},{"location":"Options/","page":"Bundle, surface, and trace options","title":"Bundle, surface, and trace options","text":"trace_extract_terminus returns requested ray information for all rays in trace or bigtrace as Matrix at the requested propagation position.\ntrace_extract_ray returns requested ray information for the i,j ray in the trace or bigtrace at all positions in propagation as a vector.","category":"page"},{"location":"Options/","page":"Bundle, surface, and trace options","title":"Bundle, surface, and trace options","text":"Built-in evaluation methods on trace or bigtrace types return numbers or plots:","category":"page"},{"location":"Options/","page":"Bundle, surface, and trace options","title":"Bundle, surface, and trace options","text":"rms_spot returns the rms-sense spot size of all rays in the trace at a particular position in propagation. \nsplot is a spot plot, and returns a plot of lateral ray coordinates of the bundle at a particular position in propagation. \nrac returns a line plot of ray coordinates at one position in propagation as a function of the same coordinates at a different point in propagation.","category":"page"},{"location":"Examples/#Examples-(2D-and-3D)","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"","category":"section"},{"location":"Examples/#Vectorizing-over-bundle-angles","page":"Examples (2D and 3D)","title":"Vectorizing over bundle angles","text":"","category":"section"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"The Quickstart tutorial showed tracing a single bundle through a system.  Now suppose there is a need to trace multiple types of bundles through a system all at once.  Consider a system of two parabolic surfaces which have bundles incident at different angles. One could simply do the procedure in the tutorial three different ways, but this would be somewhat verbose.  Instead this can be done more efficiently by defining functions over the variables which are of interest and then calling them on vectors of the different variable values.","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"Below a setup is implemented very similarly to the tutorial, but a function bund_ang(angle) is defined to originate a bundle of fixed spatial origin but variable y-direction-tangent angle.","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"using GeometricalOptics, Plots\n\nsurfslist = [aspherical, aspherical, zplane]\ncoeffslist = [[5., -6., -1.], [1., 2., -1.], [8.]]      # two parabolic surfaces\nnlist = [1., -1., 1.]                               # index sign change means reflection\n\noptsta_instance = opticalstack(coeffslist, surfslist, nlist)\n\nbund_ang(angle) = bundle([0.], (-0.5:0.5:0.5).+1, 0., angle, 0.)","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"Then vectors to vary for the system are defined. Three different angles are of interest, and for visiblity it is best to plot in different colors and only plot surfaces along with a single set of rays (as the system does not change otherwise). Then a Plots.jl plot pane is initialized so that it can be passed into all of the vectorized cases of analysis and they can be plotted together.","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"angles = [0., 0.028, 0.04]                    # a list of three angles\ncolors = [:red, :green, :blue]                # each of which is colored differently\nissurfplotvec = [true, false, false]          # only plot surfaces along with first bundle\nplot_together_in = Plots.plot()               # must put this into the system plotter to get all angles.","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"Finally a function stack_render is defined to accept all of the varying parameters, and then the vectors are all passed into the function to return a vector of plots. The vector of plots are linked to the same original Plots.plot instance, so calling the last element of the vector of plots will show all three instances together.","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"stack_render(angle, pc, isp) = optsta_instance(bund_ang(angle); rend = \"YZ\", color = pc, numsurfpoints = 100, plobj = plot_together_in, issurfplot = isp)\n\nplot_together_out_vec = stack_render.(angles, colors, issurfplotvec)\nplot_together_out_vec[3]                    # the last entry in the vector of plots has all bundles","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"And an analogous procedure generates all of the spot plots together. A function is defined to set a now square bundle for a variable y-angle, and then another function plots all of the spots together on the final plane.","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"splot_init = Plots.plot()\n\nbund2_ang(angle) = bundle((-0.5:0.2:0.5), (-0.5:0.2:0.5).+1, 0., angle, 0.)\n\nfunction optsta_render_splot(angle, pc, isp)\n    traceout = optsta_instance(bund2_ang(angle))\n    splot(traceout, pl_splot = splot_init, color = pc)\nend\n\nsplot_vec = optsta_render_splot.(angles, colors, issurfplotvec)\nsplot_vec[3]                                # the last entry in the vector of plots has all bundles","category":"page"},{"location":"Examples/#Advantageous-start-conditions-and-fixing-a-broken-raytrace","page":"Examples (2D and 3D)","title":"Advantageous start conditions and fixing a broken raytrace","text":"","category":"section"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"Broadly, there are few ways to break the raytrace analysis. One way is to attempt to violate physics or basic geometry. Another way is due to extremely steep surface or ray angles with respect to z.  This should be tested. Still another ays is to not provide proper start conditions for numerical raytrace methods.  There is a utility to address this latter case.","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"A few other things should be tested:","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"Rays must be known to converge on the surface.\nDon't choose a function that rolls off before the ray can hit it; that cannot be fixed.\nThe surface function must be designed to return a number at the ray incident position.\nExample: built-in zernike is defined to return NaN when outside the normalization radius, so it is designed to fail in certain cases.","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"Using a modification of the above example, it is possible to \"break\" the raytrace.  Take the same system for analysis as above, but change the parameters of the first asphere to be positioned and focused differently.  Note that a few rays traced through the first surface are traced erratically.  This is due to improper convergence of numerical raytracing.","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"using GeometricalOptics, Plots\n\nsurfslist = [aspherical, aspherical, zplane]\ncoeffslist = [[4., -4., -1.], [1., 2., -1.], [8.]]      # two parabolic surfaces\nnlist = [1., -1., 1.]                               # index sign change means reflection\n\noptsta_instance=opticalstack(coeffslist, surfslist, nlist)\n\nbund_ang(angle) = bundle([0.], (-0.5:0.5:0.5).+1, 0., angle, 0.)\n\nangles = [0., 0.028, 0.04]                     # a list of three angles\ncolors = [:red, :green, :blue]                 # each of which is colored differently\nissurfplotvec = [true, false, false]           # only plot surfaces along with first bundle\nplot_together_in = Plots.plot()                # must put this into the system plotter to get all angles.\n\nstack_render(angle,pc,isp) = optsta_instance(bund_ang(angle); rend = \"YZ\",color = pc,ydom = -2:0.1:2, plobj = plot_together_in, issurfplot = isp)\n\nplot_together_out_vec = stack_render.(angles, colors, issurfplotvec)\nplot_together_out_vec[3]                    # the last entry in the vector of plots has all bundles\ntitle!(\"broke the trace :(\")","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"The spots show the erratic rays as well:","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"splot_init = Plots.plot()\n\nbund2_ang(angle) = bundle((-0.5:0.2:0.5), (-0.5:0.2:0.5).+1, 0., angle, 0.)\n\nfunction optsta_render_splot(angle, pc, isp)\n    traceout = optsta_instance(bund2_ang(angle))\n    splot(traceout, pl_splot = splot_init, color = pc)\nend\n\nsplot_vec = optsta_render_splot.(angles, colors, issurfplotvec)\nsplot_vec[3]                                # the last entry in the vector of plots has all bundles\ntitle!(\"broke the trace :(\")","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"This case can be fixed by using the optional argument init_prop_guesses to an instance of opticalstack.  The optional argument can be passed in as a vector of same length as the number of surfaces, or as nothing.  When nothing, all rays are first guessed to propagate zero distance to the next surface.  When passed in as a vector, each value of the vector is the initial guess of signed propagation distance to the corresponding surface. Because the error arises in finding intersection of the rays with the second surface, the initial guess for the second surface is altered, and in particular made negative (due to reflection) and given magnitude close to the distance expected for the ray.  Then all of the rays in a bundle will be traced separately, only with newly specified starting guesses for distances traversed between surfaces.","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"The issue with the raytrace is rectified by adding the vector of values to provide a better initial guess for the negative propagation to the second surface:","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"using GeometricalOptics, Plots\n\nsurfslist = [aspherical, aspherical, zplane]\ncoeffslist = [[4., -4., -1.], [1., 2., -1.], [8.]]      # two parabolic surfaces\nnlist = [1., -1., 1.]                               # index sign change means reflection\n\noptsta_instance = opticalstack(coeffslist, surfslist, nlist)\n\nbund_ang(angle) = bundle([0.], (-0.5:0.5:0.5).+1, 0., angle, 0.)\n\nangles = [0., 0.028, 0.04]                      # a list of three angles\ncolors = [:red, :green, :blue]                 # each of which is colored differently\nissurfplotvec = [true, false, false]            # only plot surfaces along with first bundle\nplot_together_in = Plots.plot()               # must put this into the system plotter to get all angles.\n\ninit_prop_guesses_choice = [0., -2., 0.]\n\nstack_render(angle, pc, isp) = optsta_instance(bund_ang(angle); rend = \"YZ\", color = pc, ydom = -2:0.1:2, plobj = plot_together_in, issurfplot = isp, init_prop_guesses = init_prop_guesses_choice)\n\nplot_together_out_vec = stack_render.(angles, colors, issurfplotvec)\nplot_together_out_vec[3]                    # the last entry in the vector of plots has all bundles\ntitle!(\"fixed the trace :)\")","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"The spots behave now too:","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"splot_init = Plots.plot()\n\nbund2_ang(angle) = bundle((-0.5:0.2:0.5), (-0.5:0.2:0.5).+1, 0., angle, 0.)\n\nfunction optsta_render_splot(angle, pc, isp)\n    traceout = optsta_instance(bund2_ang(angle); init_prop_guesses = init_prop_guesses_choice)\n    splot(traceout, pl_splot = splot_init, color = pc)\nend\n\nsplot_vec = optsta_render_splot.(angles, colors, issurfplotvec)\nsplot_vec[3]                                # the last entry in the vector of plots has all bundles\ntitle!(\"fixed the trace :)\")","category":"page"},{"location":"Examples/#Vectorizing-over-index,-3D-analysis","page":"Examples (2D and 3D)","title":"Vectorizing over index, 3D analysis","text":"","category":"section"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"The same sort of thing that was done for different bundle angles can also be done for different system configurations.  Let's examine a few variations on this, plotting in 3D instead of 2D and using a custom bundle array defined to be a circular bundle footprint.  First define the parameters of the system that are fixed. The bundle is fixed with a circular footprint defined by bundle_as_array.  The array arguments are defined such that one array subscript corresponds to a radial distance from the central axis, and another subscript corresponds to an azimuthal angle around the axis.","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"using GeometricalOptics, Plots\n\nsurfslist = [aspherical, aspherical, zplane]\ncoeffslist = [[1., 6., -5.], [2., -6., -5.], [8.]]\n# index list is no longer up here, as the material is varied in modeling.\n\nrdom = 0.01:0.2: 1.\nthdom = 0.:pi/10:2pi\nr = rdom' .* ones(length(thdom))\nth = ones(length(rdom))' .* thdom\nbund_instance = bundle_as_array(r .* cos.(th), r .* sin.(th), zeros(size(r)), zeros(size(r)), 0.)","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"Then define the variable system parameters.  The selected index values for the second material are in the vector nsel, and all three of these will be tested; results will be plotted in different colors on the same plot with surfaces only plotted alongside the first case.","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"\nnsel = [1.46, 1.5, 1.56]                # a list of three indices,\ncolors = [:red, :green, :blue]         # each of which is colored differently\nissurfplotvec = [true, false, false]    # only plot surfaces with one of the bundles.\nplot_lens_init = Plots.plot()       # must put this into the system plotter to get all cases.\n","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"Now make a function to vary the system over the desired values, and then call over the vectors defined above:","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"function optsta_render(n_u, pc, isp)\n    nlist_chr = [1., n_u, 1.]\n    optsta_instance = opticalstack(coeffslist, surfslist, nlist_chr)\n    optsta_instance(bund_instance; rend = \"3Dcirc\", color = pc, numsurfpoints = 100, plobj = plot_lens_init, issurfplot = isp)\nend\n\nplot_lens_vec = optsta_render.(nsel, colors, issurfplotvec)\nplot_lens_vec[3]                # only need to plot the last of the three elements in the vector; it caught all cases.","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"Using the same configuration, a YZ plot can be made.  This plot, with traces of a circular bundle, is a projection of all of the rays onto the YZ plane.  Thus the YZ plot (properly) appears to have irregular rays because the rays span 3D space and are projected into a 2D plane.  This is why it may be advantageous to plot fans (2D bundles) for lens viewing instead of 3D bundles, as in previous examples.","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"plot_lens_init3d = Plots.plot()  \nfunction optsta_render(n_u, pc, isp)\n    nlist_chr = [1., n_u, 1.]\n    optsta_instance = opticalstack(coeffslist, surfslist, nlist_chr)\n    optsta_instance(bund_instance; rend = \"YZ\", color = pc, numsurfpoints = 100, plobj = plot_lens_init3d, issurfplot = isp)\nend\nplot_lens_vec3d = optsta_render.(nsel, colors, issurfplotvec)\nplot_lens_vec3d[3]                 # only need to plot the last of the three elements in the vector; it caught all cases.","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"Finally, an analogous process is used to get the spot plot.  Different index of refraction corresponds to different size of the spot for this configuration.","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"splot_init = Plots.plot()\nfunction optsta_render_splot(n_u, pc, isp)\n    nlist_chr = [1., n_u, 1.]\n    optsta_instance = opticalstack(coeffslist, surfslist, nlist_chr)\n    traceout = optsta_instance(bund_instance)\n    splot(traceout, pl_splot = splot_init, color = pc, markersize = 3)\nend\nsplot_vec = optsta_render_splot.(nsel, colors, issurfplotvec)\nsplot_vec[3]","category":"page"},{"location":"Examples/#custSurf","page":"Examples (2D and 3D)","title":"Sideloading a new surface function: caustics in the swimming pool","text":"","category":"section"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"Let's try to model the lines that appear when the sun strikes the surface waves on water, as in a swimming pool.  ","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"Suppose we can approximate the surface waves in a swimming pool by a sinusoid on a polynomial (a better model might exist for this, but this one is qualitatively sufficient). This function can be defined as wavy_water below and sideloaded into the raytrace analysis. The function is first defined over arguments x,y,coeffs, where x,y are lateral coordinates and coeffs::Vector{T} where T<: Real has entries which are decided by the user.  Then put the function list and put a corresponding coefficient vector with desired values into coeffslist.","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"The different densities of the ray spots at the analysis plane generates a wavy line pattern as can be seen at the bottom of a swimming pool.","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"using GeometricalOptics\n\nwavy_water(x, y, coeffs) = coeffs[1] + coeffs[2] * cos(coeffs[3] * (x^2 * 0.05 + 0.2*x +y))\n\nsurfslist = [wavy_water, zplane]\ncoeffslist = [[1., 0.1, 3.], [8.]]\nnlist = [1., 1.33]\noptsta_instance = opticalstack(coeffslist, surfslist, nlist)\n\nbund_instance = bundle((-2:0.1:2), (-2:0.1:2), 0., 0., 0.)\n\ntraceout = optsta_instance(bund_instance)\nplot_spot = splot(traceout)","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"To view the raytrace, let's use a less dense bundle than the one used for evaluation.  The rays and surfaces can be viewed from the side. Note that the side plot shows a projection of all rays in the bundle with various different angles.","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"bund_instance = bundle((-2:0.5:2), (-2:0.5:2), 0., 0., 0.)\nplot_sys = optsta_instance(bund_instance, rend = \"YZ\")","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"Or the rays and surfaces can be viewed in 3D. The bottom of the pool is at the top of the fixed view pane shown below.  This is better observed when the plot is viewed interactively - try it out!","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"plot_sys2 = optsta_instance(bund_instance, rend = \"3Dsq\")","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"This example illustrates how a user defined surface of arbitrary shape can be directly used in analysis, accepting a vector of coefficients just as for built-in functions.","category":"page"},{"location":"Examples/#grin","page":"Examples (2D and 3D)","title":"Advanced: Gradient index (GRIN) lens with flat surfaces","text":"","category":"section"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"The index of refraction can vary continuously in a material.  Light can be focused with a gradient index distribution even in the absence of a curved surface.  This can be modeled by replacing the index entry with a quadratic GRIN function and passing a couple extra arguments to the opticalstack for the coefficients of the index function and the discrete ray sampling in the GRIN medium.","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"First the quadratic GRIN coefficient is calculated to give the approximate desired focal length for a given thickness of the GRIN, and the GRIN function for use is defined. It must be written as n(x,y,z,coeffs) where coeffs is the coefficient vector mapped into the GRIN function and x,y,z are the coordinates being modeled. ","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"using GeometricalOptics \n\nf = 10.               # some quick physical calculation to get approximate focal length\nt = 2.\nn_r2 = -1 / 2 / f / t\n\nn_custom(x, y, z, coeffs) = coeffs[1] + coeffs[2] * (x^2 + y^2)","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"Now the system opticalstack is set up almost exactly the same except now with two more arguments. dt sets the GRIN step size and n_coeffslist provides a list of coefficient lists accessible to an index function at a corresponding position in nlist.  In this way, n_coeffslist serves the GRIN analogous to how coeffslist serves surfaces in construction.","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"\nsurfslist = [zplane, zplane, zplane]\ncoeffslist = [[1.], [1 + t], [1 + t + f]]\nnlist = [1., n_custom, 1.]\n\ndt = 0.003                                # set the discrete step of the curved raytrace\nn_coeffslist = [[0.], [1.5, n_r2], [0.]]     # only entries where values matter are those \n                                        #   corresponding to entries of nlist which are functions\n\noptsta_instance = opticalstack(coeffslist, surfslist, nlist, n_coeffslist, dt)","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"Then a y-fan can be traced and the YZ cross-section plotted:","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"bund_instance = bundle([0.], (-4:0.5:4), 0., 0., 0.)\nplot_lens = optsta_instance(bund_instance; rend = \"YZ\")","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"And the ray position at input and output in the y direction can be compared:","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"traceout = optsta_instance(bund_instance)\nplot_rac = rac(traceout, 1, 4)","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"\"Whoa,\" you say, \"that doesn't look right, my input and output ray coordinates are not the same size as this plot would suggest!\"  That would be correct.  The reason is that the GRIN implementation traces a bunch of tiny ray segments and stores them in the trace or bigtrace output.  Unlike for the basic systems with reflective or refractive surfaces, now the propagation subscripts of the rays in the bundle are no longer linked to the number of surfaces, but to the number of surfaces plus the number of ray increments in the GRIN.","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"Let's extract a ray and examine its subscript length.  Just arbitrarily pick the first ray in the trace here:","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"zvalues_ray11 = trace_extract_ray(traceout, 1, 1; coord = \"z\")\nlength(zvalues_ray11)","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"And now it is apparent that the ray had to be traced in a total of 598 segments to meet the GRIN ray increment resolution of dt=0.003.  Using this information identifies the propagation position corresponding to the intersection of the ray with the last plane.","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"traceout = optsta_instance(bund_instance)\nplot_rac = rac(traceout, 1, 598)","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"Note that when using this in vectorized form or with dense ray bundles, the GRIN implementation will slow the raytrace for small chosen values of dt.  This is a trade of speed and accuracy that should be made carefully.","category":"page"},{"location":"Examples/#grating","page":"Examples (2D and 3D)","title":"Advanced: Grating/hologram/metasurface lens","text":"","category":"section"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"The procedure to raytrace through gratings, holograms, and metasurfaces is the same, as all three contribute a phase perturbation to the wavefront local to the ray intersection with a surface.  ","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"It is worth noting that although the raytrace procedure is the same for gratings, holograms, and metasurfaces, their real use can be quite different.","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"First a few calculations for the coefficient of the quadratic diffractive are carried out, and the wavelength in system units is defined as 0.00055.  When the system units are taken to be millimeters, this wavelength corresponds to green light.  All physical quantities in this package must be entered with consistent units; choice of this consistent unit scale is flexible.","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"using GeometricalOptics\n\nlambda_wl = 0.00055 # note: must keep units consistent!\nf = 7.\nquad_opl_cff = -1 / 2 / f\nquad_phase_cff = 2 * pi / lambda_wl * quad_opl_cff\n\nphase_custom(x, y, z, coeffs) = coeffs[1] * (x^2 + y^2)","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"The diffraction grating is defined by a volume phase function in a list of functions (difflist below) sampled by a surface in surflist. A volume phase function phase_custom(x,y,z,coeffs) is defined with a quadratic profile to accept the calculated coefficient value in the coefficient vector coeffs.  The volume phase function phi(xyz) is used to get the real phase contribution phi_surf(xy) on an arbitrarily shaped surface z(xy) by","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"phi_surf(x y) = phi(x y z(x y))","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"There is no restriction on the shape of the surface. This enables a phase function on a freeform surface to be modeled.","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"Where there are no diffraction gratings, the entry in difflist should be zero.  A vector of integers (diffmlist below) and a vector of vectors (diffcoeffslist below) are passed in alongside the diffraction function vector to pass in the desired diffraction order and the vector of coefficients for all diffractive gratings.  The entries to these later vectors are only important when the entry in difflist is a function and nonzero.","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"Important note: the index of refraction before and after the diffractive surface must be equal. If the desired physical system has two different materials on either side of the diffractive, then the system should be modeled as a sequence of a diffractive surface and an identically located and defined reflective or refractive surface.","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"\ndifflist = [phase_custom, 0.]\ndiffmlist = [1, 0]\ndiffcoeffslist = [[quad_phase_cff], [1.]]\n\nsurfslist = [zplane, zplane]\ncoeffslist = [[1.], [8.]]\nnlist = [1., 1.]\n\noptsta_instance = opticalstack(coeffslist, surfslist, nlist, difflist, diffcoeffslist, diffmlist, lambda_wl)\n\nbund_instance = bundle([0.], (-4:0.5:4), 0., 0., 0.)\nplot_lens = optsta_instance(bund_instance; rend = \"YZ\")","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"The plot of the y coordinates of the YZ fan at input and output positions in propagation are then given","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"traceout = optsta_instance(bund_instance)\nplot_rac = rac(traceout, 1, 3)","category":"page"},{"location":"Examples/","page":"Examples (2D and 3D)","title":"Examples (2D and 3D)","text":"Noting the vertical scale, it is observed how raytraced diffractives theoretically promise tight or even \"perfect\" focusing.  The imperfect performance of this diffractive is appreciated only when the wave nature of light is considered, which is outside the scope of pure ray-based analysis.","category":"page"},{"location":"#GeometricalOptics.jl","page":"GeometricalOptics.jl","title":"GeometricalOptics.jl","text":"","category":"section"},{"location":"#Overview","page":"GeometricalOptics.jl","title":"Overview","text":"","category":"section"},{"location":"","page":"GeometricalOptics.jl","title":"GeometricalOptics.jl","text":"GeometricalOptics.jl is a simple, compact, and extensible tool for optical raytrace evaluation in the Julia Programming Language.  ","category":"page"},{"location":"","page":"GeometricalOptics.jl","title":"GeometricalOptics.jl","text":"The language of this package can be defined by the sequence:","category":"page"},{"location":"","page":"GeometricalOptics.jl","title":"GeometricalOptics.jl","text":"Bundle -> Optical System (Stack) -> Trace","category":"page"},{"location":"","page":"GeometricalOptics.jl","title":"GeometricalOptics.jl","text":"Where a Bundle represents a set of input rays, an Optical System or Stack receives and operates on the Bundle, and the returned object is a Trace, which contains the information about how the input Bundle traversed the Optical System.","category":"page"},{"location":"","page":"GeometricalOptics.jl","title":"GeometricalOptics.jl","text":"This package was designed with simplicity and extensibility as high priorities (but, of course, the user community will determine whether this goal was met).  As is seen in the Quickstart tutorial, an optical system can be defined and analyzed in very few lines of code and minimal package-specific language where it can be avoided.  Then Examples (2D and 3D) shows how the general framework extends and how other functionality can be added to the system under analysis.  Examples include implementing a custom surface, implementing a custom gradient index, and implementing a custom grating/hologram/metasurface.","category":"page"},{"location":"","page":"GeometricalOptics.jl","title":"GeometricalOptics.jl","text":"This tool is not a substitute for, but rather an accompaniment to, education in optics and photonics. Minimal jargon is used in the docs, though optical concepts will be apparent in spite of this.  The developer hopes this is a useful educational tool, and that it also serves as a good toolbox for exploring different functional forms of raytraced optical functions.","category":"page"},{"location":"#Installation","page":"GeometricalOptics.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"GeometricalOptics.jl","title":"GeometricalOptics.jl","text":"Add GeometricalOptics.jl using Pkg:","category":"page"},{"location":"","page":"GeometricalOptics.jl","title":"GeometricalOptics.jl","text":"using Pkg; Pkg.add(\"GeometricalOptics\")","category":"page"},{"location":"","page":"GeometricalOptics.jl","title":"GeometricalOptics.jl","text":"Though not strictly necessary for basic analyses, it is also highly recommended to add Plots.jl.  This will appear in some of the examples.","category":"page"},{"location":"#Roadmap","page":"GeometricalOptics.jl","title":"Roadmap","text":"","category":"section"},{"location":"","page":"GeometricalOptics.jl","title":"GeometricalOptics.jl","text":"The package will be periodically updated with the following objectives in mind, in order of decreasing priority:","category":"page"},{"location":"","page":"GeometricalOptics.jl","title":"GeometricalOptics.jl","text":"Technical function bug fixes\nImproved interoperability between functions and types of GeometricalOptics.jl\nImproved consistency with base Julia (generalizing or narrowing type declarations, for example)\nImproved intraoperability with other packages\nGeneralization of existing functions\nNew functions","category":"page"},{"location":"#How-to-support","page":"GeometricalOptics.jl","title":"How to support","text":"","category":"section"},{"location":"","page":"GeometricalOptics.jl","title":"GeometricalOptics.jl","text":"Support this project by","category":"page"},{"location":"","page":"GeometricalOptics.jl","title":"GeometricalOptics.jl","text":"Making contact - indicating support, comments, or issues on Github\nCiting the package\nContributing to the package","category":"page"},{"location":"#License","page":"GeometricalOptics.jl","title":"License","text":"","category":"section"},{"location":"","page":"GeometricalOptics.jl","title":"GeometricalOptics.jl","text":"This package is provided for use under the MIT License.","category":"page"}]
}
