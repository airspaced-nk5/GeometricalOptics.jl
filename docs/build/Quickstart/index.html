<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quickstart tutorial · GeometricalOptics.jl</title><meta name="title" content="Quickstart tutorial · GeometricalOptics.jl"/><meta property="og:title" content="Quickstart tutorial · GeometricalOptics.jl"/><meta property="twitter:title" content="Quickstart tutorial · GeometricalOptics.jl"/><meta name="description" content="Documentation for GeometricalOptics.jl."/><meta property="og:description" content="Documentation for GeometricalOptics.jl."/><meta property="twitter:description" content="Documentation for GeometricalOptics.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="GeometricalOptics.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="GeometricalOptics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">GeometricalOptics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">GeometricalOptics.jl</a></li><li class="is-active"><a class="tocitem" href>Quickstart tutorial</a><ul class="internal"><li><a class="tocitem" href="#System-geometry"><span>System geometry</span></a></li><li><a class="tocitem" href="#Ray-geometry"><span>Ray geometry</span></a></li><li><a class="tocitem" href="#Evaluation-and-plotting"><span>Evaluation and plotting</span></a></li><li class="toplevel"><a class="tocitem" href="#*Now,-what-next?*"><span><em>Now, what next?</em></span></a></li></ul></li><li><a class="tocitem" href="../Options/">Bundle, surface, and trace options</a></li><li><a class="tocitem" href="../Examples/">Examples (2D and 3D)</a></li><li><a class="tocitem" href="../TroubleConv/">Troubleshooting and Conventions</a></li><li><a class="tocitem" href="../Reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Quickstart tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Quickstart tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/airspaced-nk5/GeometricalOptics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/airspaced-nk5/GeometricalOptics.jl/blob/master/docs/src/Quickstart.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Quickstart-tutorial"><a class="docs-heading-anchor" href="#Quickstart-tutorial">Quickstart tutorial</a><a id="Quickstart-tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Quickstart-tutorial" title="Permalink"></a></h1><p>A lens can easily be defined, plotted, and evaluated in ten lines of code as shown in this tutorial.  The first few lines are for definition of system geometry, then bundle definition defines the rays for analysis, and finally the evaluation of the optical stack on the bundle yields the trace and plots used for analysis.</p><h2 id="System-geometry"><a class="docs-heading-anchor" href="#System-geometry">System geometry</a><a id="System-geometry-1"></a><a class="docs-heading-anchor-permalink" href="#System-geometry" title="Permalink"></a></h2><p>The system geometry is defined by </p><pre><code class="language-julia hljs">using GeometricalOptics

funcsList = [spherical, spherical, zplane]
coeffsList = [[1., 6.], [2., -6.], [8.]]
nList = [1., 1.5, 1.]

optSta = opticalstack(coeffsList, funcsList, nList)</code></pre><p>To understand how this works, note that each surface in <code>funcsList</code> has an associated <code>Vector</code> in <code>coeffsList</code> and value in <code>nList</code>. The positions in all three <code>Vector</code>s line up. The coefficient list entry is used for the corresponding surface, and the index of refraction entry is for the space preceding the corresponding surface. The &quot;precedence&quot; in the previous sentence is set by the sequence of the surfaces in <code>surfList</code> and therefore the order of traversal of the surfaces by the ray bundle. By contrast, surface precedence is <strong>not</strong> explicitly implied by the definition of the surface geometry.  This is useful for defining different types of systems.</p><p>The <code>spherical</code> surface has its own coefficient <code>Vector</code> definition. It is <a href="../Reference/#GeometricalOptics.spherical-Tuple{Real, Real, Vector{T} where T&lt;:Real}"><code>spherical(x,y,coeffs)</code></a> where <code>coeffs=[zpos,signed_radius]</code> with entries z-position and signed radius, accordingly.  This functionality extends to allow simple user defined functions: the user can define a new function <code>my_ytilt(x,y,coeffs)=coeffs[1]+coeffs[2]*y</code>, which creates a tilted plane with z position set by the first entry in <code>coeffs</code> and y tilt set by the second entry.  The user would then pass in <code>my_ytilt</code> with no arguments to the function list vector (<code>funcsList</code> above).  This is explored with a more complicated and fun surface in <a href="../Examples/#custSurf">Sideloading a new surface function: caustics in the swimming pool</a>.</p><p>Here there are three surfaces.  System units are arbitrary and can be prescribed based on the needs of demonstration.  The light will propagate through air (index of refraction n=1.0) to a <a href="../Reference/#GeometricalOptics.spherical-Tuple{Real, Real, Vector{T} where T&lt;:Real}"><code>spherical</code></a> surface with apex at z=1 and radius +6.0, and then refract into a medium of n=1.5.  Then the light will propagate through a glass (n=1.5) to a second surface with apex at z=2 and radius -6.0.  Finally the light will refract back out to air and propagate to a z-plane (<a href="../Reference/#GeometricalOptics.zplane-Tuple{Real, Real, Vector{T} where T&lt;:Real}"><code>zplane</code></a>) at z=8.0.</p><h2 id="Ray-geometry"><a class="docs-heading-anchor" href="#Ray-geometry">Ray geometry</a><a id="Ray-geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Ray-geometry" title="Permalink"></a></h2><p>The least verbose method to trace a bundle of light is by using the square bundle definition <a href="../Reference/#GeometricalOptics.bundle"><code>bundle(x,y,angx,angy,zpos)</code></a>. Other bundles are possible; for example, <a href="../Reference/#GeometricalOptics.bundle_as_array"><code>bundle_as_array</code></a> can make a circular bundle as shown in <a href="../Examples/#Vectorizing-over-index,-3D-analysis">Vectorizing over index, 3D analysis</a>. In this construction, <code>x,y,zpos</code> are physical positions, and <code>angx,angy</code> are tilts in radians away from the z-axis in the x and y directions respectively (arguments of direction tangents).  By convention, the rays all originate from the same z position given by scalar <code>zpos</code>. Arguments <code>x,y</code> can be <code>Vector</code>s and the rest scalars to make the bundle of rays all parallel or collimated.  These <code>Vector</code>s need not be the same length; this sets the count of the rays in either direction. If <code>x::Vector{T} where T&lt;:Real = [0.]</code> as below, the rays will all begin with coordinate x=0, and have y values given by the extent of the vector in y.</p><pre><code class="language-julia hljs">test_bundle = bundle([0.], (-1:0.2:1), 0., 0., 0.)</code></pre><p>Analogously, another bundle can be traced but have <code>angx,angy</code> as <code>Vector</code>s and all other arguments as scalars. This would correspond with all rays originating from a point in space with a particular array of angles.  In any event, the <a href="../Reference/#GeometricalOptics.bundle"><code>bundle</code></a> represents an array of input rays.</p><h2 id="Evaluation-and-plotting"><a class="docs-heading-anchor" href="#Evaluation-and-plotting">Evaluation and plotting</a><a id="Evaluation-and-plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation-and-plotting" title="Permalink"></a></h2><p>The output of the method on the instance of <a href="../Reference/#GeometricalOptics.opticalstack"><code>opticalstack</code></a> is variable depending on keyword. </p><p>With a bundle passed in and no render optional argument <code>rend</code> used the default output is a <a href="../Reference/#GeometricalOptics.trace"><code>trace</code></a>.</p><p>Passed into <a href="../Reference/#GeometricalOptics.rac-Tuple{Any, Any, Any}"><code>rac</code></a>, the ray lateral coordinate at one position in trajectory can be plotted as a function of ray lateral coordinate at another position.  In this case, the position is related to the ray bundle information.  Index 1 corresponds to the set of ray information before striking any surfaces, and the last index corresponds to the ray information at the last requested surface.  Therefore when traveling through k surfaces, the number of positions along ray trajectory will be (k+1).  The three-surface system is evaluated at ray position four with respect to ray position one.</p><pre><code class="language-julia hljs">trace1 = optSta(test_bundle)
p_rac = rac(trace1, 1, 4)</code></pre><img src="ccdbe25f.svg" alt="Example block output"/><p>The bundle strikes the final surface on a z-plane.  Root-mean-square ray deviation <a href="../Reference/#GeometricalOptics.rms_spot-Tuple{Any}"><code>rms_spot</code></a> with no optional keyword <code>pos</code> is evaluated at the last surface.</p><pre><code class="language-julia hljs">rms = rms_spot(trace1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.03846450937451718</code></pre><p>The <a href="../Reference/#GeometricalOptics.trace"><code>trace</code></a> can be evaluated by other means using the evaluation functions explained in <a href="../Options/#Bundle,-surface,-and-trace-options">Bundle, surface, and trace options</a>. The <a href="../Reference/#GeometricalOptics.bigtrace"><code>bigtrace</code></a> type stores more information than the <a href="../Reference/#GeometricalOptics.trace"><code>trace</code></a> type and can be extracted by setting optional argument <code>isbigtrace=true</code> into the <code>opticalstack</code> call. </p><p>If the render mode keyword <code>rend</code> is used, the output is a plot, here set as a 2D plot of the lens in the YZ plane:</p><pre><code class="language-julia hljs">p_lens = optSta(test_bundle; rend = &quot;YZ&quot;)</code></pre><img src="586d5ea0.svg" alt="Example block output"/><p>Argument options for plotting are <code>rend=&quot;YZ&quot;</code>, <code>rend=&quot;XZ&quot;</code>, <code>rend=&quot;3Dcirc&quot;</code>, <code>rend=&quot;3Dsq&quot;</code>.  The global plot domain of surfaces can be adjusted by <code>xdom</code> and <code>ydom</code>.</p><p>The various plots can be plotted statically as shown in the docs or as <strong>interactive plots</strong> by using the plotly backend of Plots with this package. Just add <code>using Plots; Plots.plotly()</code> and the plots will be interactive.</p><pre><code class="language-julia hljs">p_lens = optSta(test_bundle; rend = &quot;YZ&quot;, ydom = -2:0.1:2)</code></pre><img src="4bb78cdb.svg" alt="Example block output"/><p>Yes, this is the eleventh line of code for those of you keeping count, and I said ten lines. But it&#39;s not necessary to repeat the plotting operation. You get the point :)</p><h1 id="*Now,-what-next?*"><a class="docs-heading-anchor" href="#*Now,-what-next?*"><em>Now, what next?</em></a><a id="*Now,-what-next?*-1"></a><a class="docs-heading-anchor-permalink" href="#*Now,-what-next?*" title="Permalink"></a></h1><p>There are other methods and types in GeometricalOptics.jl which can be used, and this package can be interfaced with other packages in Julia.  Other more complicated demonstrations can be constructed as in <a href="../Examples/#Examples-(2D-and-3D)">Examples (2D and 3D)</a>. But the core functionality still remains the same as in this tutorial.  The <a href="../Reference/#GeometricalOptics.opticalstack"><code>opticalstack</code></a> connects a bundle of rays and with a sequence of surfaces. Simply substitute different functions for surfaces or vectorize over lenses to look at different configurations depending on the behavior you wish to demonstrate.  Other bundle prescriptions are also possible.  The abstract vectorization of Julia allows a surprisingly intuitive extension of this simpler example to other practical demonstrations.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« GeometricalOptics.jl</a><a class="docs-footer-nextpage" href="../Options/">Bundle, surface, and trace options »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Tuesday 14 January 2025 22:30">Tuesday 14 January 2025</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
