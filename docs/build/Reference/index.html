<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · GeometricalOptics.jl</title><meta name="title" content="Reference · GeometricalOptics.jl"/><meta property="og:title" content="Reference · GeometricalOptics.jl"/><meta property="twitter:title" content="Reference · GeometricalOptics.jl"/><meta name="description" content="Documentation for GeometricalOptics.jl."/><meta property="og:description" content="Documentation for GeometricalOptics.jl."/><meta property="twitter:description" content="Documentation for GeometricalOptics.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="GeometricalOptics.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="GeometricalOptics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">GeometricalOptics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">GeometricalOptics.jl</a></li><li><a class="tocitem" href="../Quickstart/">Quickstart tutorial</a></li><li><a class="tocitem" href="../Options/">Bundle, surface, and trace options</a></li><li><a class="tocitem" href="../Examples/">Examples (2D and 3D)</a></li><li><a class="tocitem" href="../TroubleConv/">Troubleshooting and Conventions</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/airspaced-nk5/GeometricalOptics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/airspaced-nk5/GeometricalOptics.jl/blob/master/docs/src/Reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricalOptics.bigtrace" href="#GeometricalOptics.bigtrace"><code>GeometricalOptics.bigtrace</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bigtrace(xr, yr, zr, Dxr, Dyr, Dzr, nsr)</code></pre><p>Composite type holding position, direction, and accumulated optical path for parsing. Each is Type <code>Matrix{Vector{T}} where T&lt;:Real</code>,  vector holding information along propagation and the matrix mapping to the chosen input bundle subscripting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/airspaced-nk5/GeometricalOptics.jl/blob/06c5af2601029d2190e6cb3643022f4cd1fd9f04/src/GeometricalOptics.jl#L318-L325">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricalOptics.bundle" href="#GeometricalOptics.bundle"><code>GeometricalOptics.bundle</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bundle(x, y, angx, angy, zpos)</code></pre><p>Composite type representing the origination of a bundle of rays. Input zpos is type <code>T&lt;:Real</code>  and is z-plane start position for the rays. Other four arguments are typed in one of the following two patterns:</p><ol><li>x and y are Type <code>AbstractArray{T,1} where T&lt;:Real</code>, angx and angy are Type <code>T where T&lt;:Real</code></li><li>x and y are Type <code>T where T&lt;:Real</code>, angx and angy are Type <code>AbstractArray{T,1} where T&lt;:Real</code>}</li></ol><p>When a variable is declared this type with specific parameters and called  as a function with no arguments, it returns a tuple (position, direction) each  entry of which is an output array of vectors corresponding to the input information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; eval_bundle = bundle([0., 1.], [0.,1.], 0., 0., 0.)
bundle([0.0, 1.0], [0.0, 1.0], 0.0, 0.0, 0.0)

julia&gt; eval_bundle()
([[0.0, 0.0, 0.0] [0.0, 1.0, 0.0]; [1.0, 0.0, 0.0] [1.0, 1.0, 0.0]], [[0.0, 0.0, 1.0] [0.0, 0.0, 1.0]; [0.0, 0.0, 1.0] [0.0, 0.0, 1.0]])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/airspaced-nk5/GeometricalOptics.jl/blob/06c5af2601029d2190e6cb3643022f4cd1fd9f04/src/GeometricalOptics.jl#L165-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricalOptics.bundle_as_array" href="#GeometricalOptics.bundle_as_array"><code>GeometricalOptics.bundle_as_array</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bundle_as_array(x, y, angx, angy, zpos)</code></pre><p>Composite type representing the origination of a set of rays. First four arguments are  Type <code>AbstractMatrix{T} where T&lt;:Real</code>; last argument is a scalar for the z position.</p><p>When a variable is declared this type with specific parameters and called  as a function with no arguments, it returns a tuple (position, direction) each  entry of which is an output array of vectors corresponding to the input information.</p><p><strong>NOTE</strong> if types of entries in inputs are known to all be the same, use <code>bundle_as_array_fast</code> with same syntax for increased speed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; eval_bundle = bundle_as_array([0.5 1.], [0.5 1.], [0. 0.], [0. 0.], 0.)
bundle_as_array{Float64}([0.5 1.0], [0.5 1.0], [0.0 0.0], [0.0 0.0], 0.0)

julia&gt; eval_bundle()
([[0.5000000000000002, 0.5000000000000002, 2.220446049250313e-16] [1.0000000000000002, 1.0000000000000002, 2.220446049250313e-16]], [[0.0, 0.0, 1.0] [0.0, 0.0, 1.0]])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/airspaced-nk5/GeometricalOptics.jl/blob/06c5af2601029d2190e6cb3643022f4cd1fd9f04/src/GeometricalOptics.jl#L220-L240">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricalOptics.bundle_as_array_big" href="#GeometricalOptics.bundle_as_array_big"><code>GeometricalOptics.bundle_as_array_big</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bundle_as_array_big(x, y, z, Dx, Dy, Dz)</code></pre><p>Composite type representing the origination of a set of rays. All arguments are Type <code>AbstractArray{T,2} where T&lt;:Real</code>.</p><p><strong>NOTE</strong> if all input arrays are guaranteed to have the same type, then use <code>bundle_as_array_big_fast</code> with same syntax for increased speed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/airspaced-nk5/GeometricalOptics.jl/blob/06c5af2601029d2190e6cb3643022f4cd1fd9f04/src/GeometricalOptics.jl#L270-L277">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricalOptics.opticalstack" href="#GeometricalOptics.opticalstack"><code>GeometricalOptics.opticalstack</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">opticalstack_instance = opticalstack( ... )

... = opticalstack_instance( ... )</code></pre><p>For surface reflection and refraction use this method to define an instance of the <code>opticalstack</code> type</p><pre><code class="nohighlight hljs">opticalstack(coeffslist, surfslist, nlist)</code></pre><p>For gradient index (and surface reflection and refraction) use this method to define an instance of the <code>opticalstack</code> type</p><pre><code class="nohighlight hljs">opticalstack(coeffslist, surfslist, nlist, ncoeffslist, grindt)</code></pre><p>For grating/hologram/metasurface (and surface reflection and refraction) use this method to define an instance of the <code>opticalstack</code> type</p><pre><code class="nohighlight hljs">opticalstack(coeffslist, surfslist, nlist, diffractiveslist, diffcoeffslist, diffmlist, wavelength)</code></pre><p>To use all features together use this method to define an instance of the <code>opticalstack</code> type</p><pre><code class="nohighlight hljs">opticalstack(coeffslist, surfslist, nlist, diffractiveslist, diffcoeffslist, diffmlist, wavelength, ncoeffslist, grindt)</code></pre><p>Arguments to create an instance of <code>opticalstack</code> are </p><ul><li><p><code>coeffslist</code> is a <code>Vector</code> set of coefficients for a corresponding surface; each set of coefficients is itself also a <code>Vector</code>.</p></li><li><p><code>surfslist</code> is a <code>Vector</code> of functions callable on <code>(x, y, coeffs)</code> to return a z-zurface position.</p></li><li><p><code>nlist</code> is a <code>Vector</code> of index values or index functions corresponding to the medium before the corresponding surface.</p><ul><li>Vector values T&lt;:Real work universally</li><li>Vector input of mixed type, <code>Real</code> and functions <code>n</code> where <code>n(x, y, z, coeffs) = ...</code>, only works for declarations of <code>opticalstack</code> which define <code>ncoeffslist</code> and <code>grindt</code> as well.</li></ul></li><li><p><code>ncoeffslist::Vector{Vector{T}} where T&lt;:Real</code> is a <code>Vector</code> set of coefficients for a corresponding gradient index; each set of coefficients is itself also a <code>Vector</code>.</p></li><li><p><code>grindt::Real</code> is the Sharma ray increment in the gradient index medium. </p><ul><li>This step parameter scales the physical quantity <span>$OP/n²$</span> (optical path length and index of refraction) at every step, and raytracing is by the algorithm of Sharma et al. 1982.</li></ul></li><li><p><code>diffractiveslist</code> is a <code>Vector</code> of zeros and functions. Where a vector entry is not zero, the entry must be a valid phase function, e.g. <span>$ϕ$</span> where <span>$ϕ(x, y, z, coeffs) = ...$</span> sampled by the surface at a corresponding position to make the diffractive.</p></li><li><p><code>diffcoeffslist::Vector{Vector{T}} where T&lt;:Real</code> is a <code>Vector</code> set of coefficients for a corresponding diffractive; each set of coefficients is itself also a <code>Vector</code>.</p></li><li><p><code>diffmlist::Vector{Int}</code> must have the integer corresponding to the diffraction order in the vector position corresponding to the position of the diffractive surface.</p></li><li><p><code>wavelength::Real</code> is the wavelength in system units simulated for the definition of the diffractive.</p></li></ul><p>When an instance is declared, <code>opticalstack_instance = opticalstack( ... )</code>, the declared instance is called on a bundle instance <code>bundlething</code> and optional arguments as</p><pre><code class="nohighlight hljs">opticalstack_instance(bundlething; rend = nothing, color = :red, issurfplot = true, numsurfpoints = 20, halfdomain = nothing, xdom = nothing, ydom = nothing, plobj = nothing, isbigtrace = false, plotplane_at = 0., init_prop_guesses=nothing)</code></pre><ul><li><p>When <code>rend</code> is <code>nothing</code> and <code>isbigtrace = false</code> the output is a <code>trace</code> type.</p></li><li><p>When <code>rend</code> is <code>nothing</code> and <code>isbigtrace = true</code> the output is a <code>bigtrace</code> type.</p></li><li><p>When <code>rend</code> is not <code>nothing</code>, <code>rend</code> must be <code>&quot;YZ&quot;</code> or <code>&quot;XZ&quot;</code> or <code>&quot;3Dcirc&quot;</code> or <code>&quot;3Dsq&quot;</code>. The output will be a plot object compatible with Plots.jl</p></li><li><p>When <code>rend</code> is not <code>nothing</code> and <code>issurfplot = false</code> the surfaces being modeled will not be plotted.</p></li><li><p>The domain plot can be scaled globally by entering a vector of desired plot extent into <code>xdom</code> or <code>ydom</code>. This is preferred over using <code>numsurfpoints</code> and <code>halfdomain.</code></p></li><li><p><code>plotplane_at</code> is the value at which a 2D plot is sliced in the non-plotted dimension.</p></li><li><p><code>init_prop_guesses::Vector{T} where T&lt;:Real</code> is an option to declare a first guess in numerical propagation preceding surface in the corresponding vector entry. </p><ul><li>Defaults to zero.</li><li>Not recommended to use a nonzero value when traversing a gradient index function. </li></ul></li></ul><p><strong>Note</strong> that the data scaling of the output of gradient index analysis is not only with the number of rays but also with the resolution of propagation.  Assuming that propagation occurs over some position difference <span>$Δz$</span>, this data scaling is APPROXIMATELY <span>$Δz$</span>/<code>dt</code>. As expected, <code>dt</code> trades precision for computation time.</p><p><strong>Note</strong> for gradient index surfaces the output ray coordinates are stacked according to propagation needed for the &quot;longest&quot; gradient index ray. Therefore a returned <code>trace</code> or <code>bigtrace</code> will not be easily indexed according to its surface, but all propagation positions will properly align when entering and exiting the gradient index. Shorter rays will replicate their terminated values until the longest ray terminates. Then all rays will exit the gradient index together at the appropriate surface.</p><p><strong>Note</strong> for diffractive surfaces, the optical path contribution of the corresponding surface is that due to its preceding propagation PLUS that due to the diffraction phase function.</p><p><strong>Note</strong> that the index of refraction must be equal on both sides of the diffractive.  To work with cases where the diffractive sits on a substrate of different index of refraction, two surfaces should be collocated in sequence, one for reflection/refraction and one for diffraction.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; opticalstack_test = opticalstack([[1., 6.], [2., -6.], [4., 8.]], [spherical, spherical, zernike], [1., 1.5, 1.])
opticalstack{Float64}([[1.0, 6.0], [2.0, -6.0], [4.0, 8.0]], UnionAll[spherical, spherical, zernike], [1.0, 1.5, 1.0])

julia&gt; bundle_test = bundle([0.5, 1.], [0.5, 1.], 0., 0., 0.)
bundle([0.5, 1.0], [0.5, 1.0], 0.0, 0.0, 0.0)

julia&gt; tracething = opticalstack_test(bundle_test)
trace{Float64}([[0.5, 0.5, 0.4742890889441142, -0.024645519233983726] ... ; ...])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/airspaced-nk5/GeometricalOptics.jl/blob/06c5af2601029d2190e6cb3643022f4cd1fd9f04/src/GeometricalOptics.jl#L511-L586">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricalOptics.trace" href="#GeometricalOptics.trace"><code>GeometricalOptics.trace</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trace(xr, yr, zr, nsr)</code></pre><p>Composite type holding position and accumulated optical path for parsing. Each is Type <code>Matrix{Vector{T}} where T&lt;:Real</code>,  vector holding information along propagation and the matrix mapping to the chosen input bundle subscripting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/airspaced-nk5/GeometricalOptics.jl/blob/06c5af2601029d2190e6cb3643022f4cd1fd9f04/src/GeometricalOptics.jl#L305-L311">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricalOptics.aspherical-Tuple{Real, Real, Vector{T} where T&lt;:Real}" href="#GeometricalOptics.aspherical-Tuple{Real, Real, Vector{T} where T&lt;:Real}"><code>GeometricalOptics.aspherical</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">aspherical(x, y, coeffs)</code></pre><p>Composite type representing aspherical surface as a function of lateral coordinate <code>x,y</code>. Argument <code>coeffs</code> of type <code>Vector{T} where T&lt;:Real</code> has entries <code>coeffs = [zpos, R,</code><code>κ</code><code>, A4, A6, ...]</code> where the surface is </p><p><span>$z(x,y) = zpos + r² / R / (1 + √(1 - (1 + κ)r² / R²)) + A₄r⁴ + A₆r⁶ + ...$</span> where <span>$r² ≡ x² + y²$</span></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; aspherical(0., 2., [1., -10., -4., 0.001])
1.0616649185805458</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/airspaced-nk5/GeometricalOptics.jl/blob/06c5af2601029d2190e6cb3643022f4cd1fd9f04/src/GeometricalOptics.jl#L84-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricalOptics.bigtrace_to_bundle-Tuple{bigtrace, Int64}" href="#GeometricalOptics.bigtrace_to_bundle-Tuple{bigtrace, Int64}"><code>GeometricalOptics.bigtrace_to_bundle</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bigtrace_to_bundle(tracething::bigtrace, pos_prop::Int)</code></pre><p>Takes a <code>bigtrace</code> object and integer position <code>pos_prop</code> and returns a bundle object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/airspaced-nk5/GeometricalOptics.jl/blob/06c5af2601029d2190e6cb3643022f4cd1fd9f04/src/GeometricalOptics.jl#L335-L340">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricalOptics.rac-Tuple{Any, Any, Any}" href="#GeometricalOptics.rac-Tuple{Any, Any, Any}"><code>GeometricalOptics.rac</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rac(tracething::Union{trace, bigtrace}, pos_in, pos_out; pl_rac = nothing, color = :red, axistype = &quot;y&quot;, pmajoraxis = 2)</code></pre><p>Plots the chosen physical coordinate <code>axistype=y</code> or <code>x</code> at an end position <code>pos_out</code> of a particular <code>trace</code> or <code>bigtrace</code> object as a function of the same coordinate at input position <code>pos_in</code>. If <code>pos===nothing</code>, the last position in the trace is  used. The coordinate plots are stitched together in lines based on the chosen matrix subscript in the <code>trace</code> or <code>bigtrace</code>.  This matrix subscript is set by the optional argument <code>pmajoraxis = 2</code> or <code>1</code>. Can optionally pass in a handle to existing plot pl_rac, and change the plot color from default <code>color=:red</code> to any  of the conventional options supported by Plots.jl.</p><p>NOTE that when tracing a ray fan (a bundle with one dimension of the array having length 1), the <code>pmajoraxis</code> must be set to the correct number to span the nonunitary length of the array. Else the plot may not appear to show anything.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/airspaced-nk5/GeometricalOptics.jl/blob/06c5af2601029d2190e6cb3643022f4cd1fd9f04/src/GeometricalOptics.jl#L888-L897">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricalOptics.rms_spot-Tuple{Any}" href="#GeometricalOptics.rms_spot-Tuple{Any}"><code>GeometricalOptics.rms_spot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rms_spot(tracething::Union{trace, bigtrace}; isunsqrt = false, pos = nothing, iszincluded = true)</code></pre><p>Evaluates the rms spot size for a trace intersecting a surface. </p><p>Pass in the result of a trace, and calcuate the rms spot based on the ray values for the subscript <code>pos</code>. If  pos===nothing then the final values of the trace are used (i.e. the final surface is taken to be the evaluation surface). Option <code>isunsqrt</code> removes the square root from the calculation (returns the sum of squared error instead). The z coordinate variation is included in the calculation when <code>iszincluded == true</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; opticalstack_test = opticalstack([[1., 6.], [2., -6.], [4., 8.]], [spherical, spherical, zernike], [1., 1.5, 1.])
opticalstack{Float64}([[1.0, 6.0], [2.0, -6.0], [4.0, 8.0]], UnionAll[spherical, spherical, zernike], [1.0, 1.5, 1.0])

julia&gt; bundle_test = bundle([0.5, 1.], [0.5, 1.], 0., 0., 0.)
bundle([0.5, 1.0], [0.5, 1.0], 0.0, 0.0, 0.0)

julia&gt; tracething = opticalstack_test(bundle_test)
trace{Float64}([[0.5, 0.5, 0.4742890889441142, -0.024645519233983726] [0.5, 0.5, 0.47749522247588994, -0.04245690108918665]; [1.0, 1.0, 0.9549904449517799, -0.0849138021783733] [1.0, 1.0, 0.9616736859140215, -0.1253539680837904]], [[0.5, 0.5, 0.4742890889441142, -0.024645519233983726] [1.0, 1.0, 0.9549904449517799, -0.0849138021783733]; [0.5, 0.5, 0.47749522247588994, -0.04245690108918665] [1.0, 1.0, 0.9616736859140215, -0.1253539680837904]], [[0.0, 1.0418113625438212, 1.9623895629300963, 7.999999280260749] [0.0, 1.105086411777687, 1.904234300100513, 7.999999273328101]; [0.0, 1.105086411777687, 1.904234300100513, 7.999999273328101] [0.0, 1.169047547709123, 1.8438309411610754, 7.999999266127459]], [[0.0, 1.0418113625438212, 2.9446610481344417, 9.023361779810676] [0.0, 1.105086411777687, 2.8587256850369682, 9.064376469832027]; [0.0, 1.105086411777687, 2.8587256850369682, 9.064376469832027] [0.0, 1.169047547709123, 2.7690064459109145, 9.114214613215701]])

julia&gt; rms_spot(tracething)
0.1125476814135891</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/airspaced-nk5/GeometricalOptics.jl/blob/06c5af2601029d2190e6cb3643022f4cd1fd9f04/src/GeometricalOptics.jl#L802-L825">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricalOptics.spherical-Tuple{Real, Real, Vector{T} where T&lt;:Real}" href="#GeometricalOptics.spherical-Tuple{Real, Real, Vector{T} where T&lt;:Real}"><code>GeometricalOptics.spherical</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spherical(x, y, coeffs)</code></pre><p>Composite type representing spherical surface with apex at defined point. Argument <code>coeffs</code> of type <code>Vector{T} where T&lt;:Real</code> has entries <code>coeffs = [zpos, signed_radius]</code>. Here <code>zpos</code> is the apex and <code>signed_radius</code> has magnitude equal to the radius of the sphere  and sign which sets the direction of curvature of the sphere.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; spherical(0., 2., [1., -10.])
0.7979589711327115</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/airspaced-nk5/GeometricalOptics.jl/blob/06c5af2601029d2190e6cb3643022f4cd1fd9f04/src/GeometricalOptics.jl#L65-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricalOptics.splot-Tuple{Any}" href="#GeometricalOptics.splot-Tuple{Any}"><code>GeometricalOptics.splot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">splot(tracething::Union{trace, bigtrace}; pos=nothing, pl_splot = nothing, color = :red, markersize = 2)</code></pre><p>Plots the spot of a particular trace or bigtrace object at position <code>pos</code>. If <code>pos === nothing</code>, the last position in the trace is  used. Can optionally pass in a handle to existing plot pl_splot, and change the marker size from default <code>markersize = 2</code> and the plot color from default <code>color = :red</code> to any  of the conventional options supported by Plots.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/airspaced-nk5/GeometricalOptics.jl/blob/06c5af2601029d2190e6cb3643022f4cd1fd9f04/src/GeometricalOptics.jl#L855-L862">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricalOptics.trace_extract_ray-Tuple{bigtrace, Int64, Int64}" href="#GeometricalOptics.trace_extract_ray-Tuple{bigtrace, Int64, Int64}"><code>GeometricalOptics.trace_extract_ray</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trace_extract_ray(tracething::Union{trace, bigtrace}, i::Int, j::Int; coord = &quot;all&quot;)</code></pre><p>Takes a <code>trace</code> or <code>bigtrace</code> object and integers i,j and returns the ray at position in the traced bundle array i,j.</p><p>Coordinates are <code>x, y, z</code>, direction cosines are <code>Dx, Dy, Dz</code> and accumulated optical path is <code>ns</code>.</p><p>Optional argument coord can be set &quot;all&quot; to return all information as Matrices.  This will be passed out as</p><ul><li>x, y, z, ns for <code>trace</code> object</li><li>x, y, z, Dx, Dy, Dz, ns for <code>bigtrace</code> object</li></ul><p>Or optional argument can be set to a different string to only pass out one matrix of information.</p><ul><li>&quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;ns&quot; for <code>trace</code> object</li><li>&quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;Dx&quot;, &quot;Dy&quot;, &quot;Dz&quot;, &quot;ns&quot; for <code>bigtrace</code> object</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/airspaced-nk5/GeometricalOptics.jl/blob/06c5af2601029d2190e6cb3643022f4cd1fd9f04/src/GeometricalOptics.jl#L411-L427">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricalOptics.trace_extract_terminus-Tuple{bigtrace, Any}" href="#GeometricalOptics.trace_extract_terminus-Tuple{bigtrace, Any}"><code>GeometricalOptics.trace_extract_terminus</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trace_extract_terminus(tracething::Union{trace, bigtrace}, pos_prop::Int; coord=&quot;all&quot;)</code></pre><p>Takes a <code>trace</code> or <code>bigtrace</code> object and integer position pos_prop and returns matrices of coordinates according to the bundle.</p><p>Coordinates are <code>x,y,z</code>, direction cosines are <code>Dx,Dy,Dz</code> and accumulated optical path is <code>ns</code>.</p><p>Optional argument coord can be set &quot;all&quot; to return all information as Type <code>Matrix</code>.  This will be passed out as</p><ul><li>x, y, z, ns for <code>trace</code> object</li><li>x, y, z, Dx, Dy, Dz, ns for <code>bigtrace</code> object</li></ul><p>Or optional argument can be set to a different string to only pass out one <code>Matrix</code> of information.</p><ul><li>&quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;ns&quot; for <code>trace</code> object</li><li>&quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;Dx&quot;, &quot;Dy&quot;, &quot;Dz&quot;, &quot;ns&quot; for <code>bigtrace</code> object</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/airspaced-nk5/GeometricalOptics.jl/blob/06c5af2601029d2190e6cb3643022f4cd1fd9f04/src/GeometricalOptics.jl#L351-L366">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricalOptics.zernike-Tuple{Real, Real, Vector{T} where T&lt;:Real}" href="#GeometricalOptics.zernike-Tuple{Real, Real, Vector{T} where T&lt;:Real}"><code>GeometricalOptics.zernike</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">zernike(x, y, coeffs)</code></pre><p>Composite type representing OSA/ANSI type Zernike polynomial surface as a function of lateral coordinate <code>x, y</code>. Argument <code>coeffs</code> of type <code>Vector{T} where T&lt;:Real</code> has entries <code>coeffs = [rad, C0, C1, C2, ...]</code>. The normalization radius is <code>rad</code> and the corresponding Zernike surface is given by the contributions of the Zⱼ with arguments over the cartesian coordinates normalized to the unit disk, i.e.:</p><p><span>$z(x, y) = ∑ⱼCⱼZⱼ(r, θ)$</span> where <span>$r ≡ √( x² + y² ) / rad$</span> and <span>$θ ≡ atan(y / x)$</span></p><p><strong>NOTE this function evaluates to <code>NaN</code> outside of the normalization radius.</strong></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; zernike(0., 2., [2., 0., 1.])
2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/airspaced-nk5/GeometricalOptics.jl/blob/06c5af2601029d2190e6cb3643022f4cd1fd9f04/src/GeometricalOptics.jl#L33-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricalOptics.zplane-Tuple{Real, Real, Vector{T} where T&lt;:Real}" href="#GeometricalOptics.zplane-Tuple{Real, Real, Vector{T} where T&lt;:Real}"><code>GeometricalOptics.zplane</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">zplane(x, y, coeffs)</code></pre><p>Composite type representing a plane z(x, y) = zpos. Argument coeffs of type <code>Vector{T} where T&lt;:Real</code> has entries <code>coeffs = [zpos]</code>. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; zplane(0., 2., [3.])
3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/airspaced-nk5/GeometricalOptics.jl/blob/06c5af2601029d2190e6cb3643022f4cd1fd9f04/src/GeometricalOptics.jl#L16-L27">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../TroubleConv/">« Troubleshooting and Conventions</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Tuesday 14 January 2025 22:30">Tuesday 14 January 2025</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
